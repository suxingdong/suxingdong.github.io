---
title: Unity ObjectPool
author: East.Su
date: 2023-02-14 18:32:00 -0500
categories: [Unity, ObjectPool]
tags: [ObjectPool]
---

# 简单对象池实现
1. 创建一个新脚本并命名为“Object Pool”
2. 将脚本附加到您的游戏控制器。 
3. 打开脚本并在类定义中写入以下内容。

```c#
public static ObjectPool SharedInstance;
public List<GameObject> pooledObjects;
public GameObject objectToPool;
public int amoutToPool;

void Awake()
{
    SharedInstance = this;
}

void Start()
{
    pooledObjects = new List<GameObject>();
    GameObject tmp;
    for(int i = 0; i < amountToPool; i++)
    {
        tmp = Instantiate(objectToPool);
        tmp.SetActive(false);
        pooledObjects.Add(tmp);
    }
}

public GameObject GetPooledObject()
{
    for(int i = 0; i < amountToPool; i++)
    {
        if(!pooledObjects[i].activeInHierarchy)
        {
            return pooledObjects[i];
        }
    }
    return null;
}    

```
使用对象池
```c#
GameObject bullet = ObjectPool.SharedInstance.GetPooledObject(); 
if (bullet != null) 
{
    bullet.transform.position = turret.transform.position;
    bullet.transform.rotation = turret.transform.rotation;
    bullet.SetActive(true);
}
```

# Unity 对象池
[Source](https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main/Assets/7%20Object%20Pool)
```c#
//射单类
 public class RevisedProjectile : MonoBehaviour
    {
        //
        [SerializeField] private float timeoutDelay = 3f;

        private IObjectPool<RevisedProjectile> objectPool;

        // public property to give the projectile a reference to its ObjectPool
        public IObjectPool<RevisedProjectile> ObjectPool { set => objectPool = value; }

        //销毁
        public void Deactivate()
        {
            StartCoroutine(DeactivateRoutine(timeoutDelay));
        }

        IEnumerator DeactivateRoutine(float delay)
        {
            yield return new WaitForSeconds(delay);

            // reset the moving Rigidbody
            Rigidbody rBody = GetComponent<Rigidbody>();
            rBody.velocity = new Vector3(0f, 0f, 0f);
            rBody.angularVelocity = new Vector3(0f, 0f, 0f);

            // 回收到对象池
            objectPool.Release(this);
        }
    }
```

```c#
 using UnityEngine;
using UnityEngine.Pool;

namespace DesignPatterns.ObjectPool
{
    public class RevisedGun : MonoBehaviour
    {
        [Tooltip("Prefab to shoot")]
        [SerializeField] private RevisedProjectile projectilePrefab;
        [Tooltip("Projectile force")]
        [SerializeField] private float muzzleVelocity = 700f;
        [Tooltip("End point of gun where shots appear")]
        [SerializeField] private Transform muzzlePosition;
        [Tooltip("Time between shots / smaller = higher rate of fire")]
        [SerializeField] private float cooldownWindow = 0.1f;

        // Unity提供基于堆栈的对象池
        private IObjectPool<RevisedProjectile> objectPool;

        // 如果我们尝试返回池中已经存在的项目，则会抛出异常
        [SerializeField] private bool collectionCheck = true;

        // 对象池容量和大小设置
        [SerializeField] private int defaultCapacity = 20;
        [SerializeField] private int maxSize = 100;

        private float nextTimeToShoot;

        private void Awake()
        {
            objectPool = new ObjectPool<RevisedProjectile>(CreateProjectile,
                OnGetFromPool, OnReleaseToPool, OnDestroyPooledObject,
                collectionCheck, defaultCapacity, maxSize);
        }

        // invoked when creating an item to populate the object pool
        private RevisedProjectile CreateProjectile()
        {
            RevisedProjectile projectileInstance = Instantiate(projectilePrefab);
            projectileInstance.ObjectPool = objectPool;
            return projectileInstance;
        }

        // invoked when returning an item to the object pool
        private void OnReleaseToPool(RevisedProjectile pooledObject)
        {
            pooledObject.gameObject.SetActive(false);
        }

        // invoked when retrieving the next item from the object pool
        private void OnGetFromPool(RevisedProjectile pooledObject)
        {
            pooledObject.gameObject.SetActive(true);
        }

        // invoked when we exceed the maximum number of pooled items (i.e. destroy the pooled object)
        private void OnDestroyPooledObject(RevisedProjectile pooledObject)
        {
            Destroy(pooledObject.gameObject);
        }

        private void FixedUpdate()
        {
            // shoot if we have exceeded delay
            if (Input.GetButton("Fire1") && Time.time > nextTimeToShoot && objectPool != null)
            {

                // get a pooled object instead of instantiating
                RevisedProjectile bulletObject = objectPool.Get();

                if (bulletObject == null)
                    return;

                // align to gun barrel/muzzle position
                bulletObject.transform.SetPositionAndRotation(muzzlePosition.position, muzzlePosition.rotation);

                // move projectile forward
                bulletObject.GetComponent<Rigidbody>().AddForce(bulletObject.transform.forward * muzzleVelocity, ForceMode.Acceleration);

                // turn off after a few seconds
                bulletObject.Deactivate();

                // set cooldown delay
                nextTimeToShoot = Time.time + cooldownWindow;

            }
        }
    }
}
```

# Gameframework 对象池&引用池

## 1. 对象池
```c#
//对象池对象集成 ObjectBase，实现Release接口
public class HPBarItemObject : ObjectBase
{
    public static HPBarItemObject Create(object target)
    {
        HPBarItemObject hpBarItemObject = ReferencePool.Acquire<HPBarItemObject>();
        hpBarItemObject.Initialize(target);
        return hpBarItemObject;
    }

    protected override void Release(bool isShutdown)
    {
        HPBarItem hpBarItem = (HPBarItem)Target;
        if (hpBarItem == null)
        {
            return;
        }

        Object.Destroy(hpBarItem.gameObject);
    }
}

public class HPBarComponent : GameFrameworkComponent
{
    [SerializeField]
    private HPBarItem m_HPBarItemTemplate = null;

    [SerializeField]
    private Transform m_HPBarInstanceRoot = null;

    [SerializeField]
    private int m_InstancePoolCapacity = 16;

    private IObjectPool<HPBarItemObject> m_HPBarItemObjectPool = null;
    private List<HPBarItem> m_ActiveHPBarItems = null;
    private Canvas m_CachedCanvas = null;

    private void Start()
    {
        if (m_HPBarInstanceRoot == null)
        {
            Log.Error("You must set HP bar instance root first.");
            return;
        }

        m_CachedCanvas = m_HPBarInstanceRoot.GetComponent<Canvas>();
        //创建对象池
        m_HPBarItemObjectPool = GameEntry.ObjectPool.CreateSingleSpawnObjectPool<HPBarItemObject>("HPBarItem", m_InstancePoolCapacity);
        m_ActiveHPBarItems = new List<HPBarItem>();
    }


    private void HideHPBar(HPBarItem hpBarItem)
    {
        hpBarItem.Reset();
        m_ActiveHPBarItems.Remove(hpBarItem);
        //回收对象池
        m_HPBarItemObjectPool.Unspawn(hpBarItem);
    }


    private HPBarItem CreateHPBarItem(Entity entity)
    {
        HPBarItem hpBarItem = null;
        //从对象池中获取数据
        HPBarItemObject hpBarItemObject = m_HPBarItemObjectPool.Spawn();
        if (hpBarItemObject != null)
        {
            hpBarItem = (HPBarItem)hpBarItemObject.Target;
        }
        else
        {
            hpBarItem = Instantiate(m_HPBarItemTemplate);
            Transform transform = hpBarItem.GetComponent<Transform>();
            transform.SetParent(m_HPBarInstanceRoot);
            transform.localScale = Vector3.one;
            //注册到对象池
            m_HPBarItemObjectPool.Register(HPBarItemObject.Create(hpBarItem), true);//true 立刻取出对象
        }

        return hpBarItem;
    }
}
```
## 2. 引用池
    - 继承 IReference 实现接口Clear
    - 获取引用对象 ReferencePool.Acquire<State>()
    - 释放引用对象 ReferencePool.Release(StructData1);
```c#
using GameFramework;
using System.Collections.Generic;
using UnityEngine;

public class State : IReference
{
    string StateName;
    public State()
    {
    }
    public void Add(string StateName)
    {
        this.StateName = StateName;
    }
    public void Clear()
    {
        StateName = null;
    }
}
public class StructData : IReference
{
    string StateName;
    Vector2Int pos;
    public StructData()
    {
    }
    public void Add(string StateName, Vector2Int pos)
    {
        this.StateName = StateName;
        this.pos = pos;
    }
    public void Clear()
    {
        StateName = null;
        pos = default(Vector2Int);
    }
}

public class Player : MonoBehaviour
{
    ReferencePoolInfo[] Tem;
    State state1,state2;
    StructData StructData1, StructData2, StructData3;
    void Start()
    {
        //创建状态列表(使用引用池)
        state1 = ReferencePool.Acquire<State>();
        state1.Add("游走状态");
        state2 = ReferencePool.Acquire<State>();
        state2.Add("移动状态");

        StructData1 = ReferencePool.Acquire<StructData>();
        StructData1.Add("游走状态", new Vector2Int(0, 0));
        StructData2 = ReferencePool.Acquire<StructData>();
        StructData2.Add("移动状态", new Vector2Int(1, 15));
        StructData3 = ReferencePool.Acquire<StructData>();
        StructData3.Add("跳跃状态", new Vector2Int(4, 15));
        ReferencePool.Add<StructData>(4);

        Tem = ReferencePool.GetAllReferencePoolInfos();
        foreach (var item in Tem)
        {
            Debug.LogError(item.Type + ":" + item.UsingReferenceCount);
        }
    }
    
    public void ReleaseItem()
    {
        ReferencePool.Release(state2);
        foreach (var item in Tem)
        {
            Debug.LogError(item.Type + ":" + item.UsingReferenceCount);
        }
    }
    
    public void ReleaseList()
    {
        ReferencePool.Release(StructData1);
        ReferencePool.Release(StructData3);
        ReferencePool.RemoveAll(typeof(StructData));
        foreach (var item in Tem)
        {
            Debug.LogError(item.Type + ":" + item.UsingReferenceCount);
        }
    }
    
    public void AddItem()
    {
        StructData C = ReferencePool.Acquire<StructData>();
    }
}
```
